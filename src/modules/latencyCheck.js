// 线路延迟检测功能\nimport { SOURCE_MAP } from './downloadWays.js';\n\n/**\n * 检测单个线路的延迟\n * @param {string} url - 线路URL\n * @returns {Promise<number>} 延迟时间(ms)\n */\nasync function checkLatency(url) {\n    const startTime = performance.now();\n    try {\n        // 设置超时时间（例如3秒）\n        const timeout = 3000;\n        const timeoutPromise = new Promise((_, reject) => \n            setTimeout(() => reject(new Error('延迟检测超时')), timeout)\n        );\n\n        // 对于JSON API，我们发送一个HEAD请求来测量延迟\n        // 对于其他类型，可以考虑发送一个简单的GET请求或OPTIONS请求\n        const fetchPromise = fetch(url, { method: 'HEAD', mode: 'no-cors' });\n        \n        // 使用Promise.race来处理超时\n        await Promise.race([fetchPromise, timeoutPromise]);\n        \n        const endTime = performance.now();\n        return endTime - startTime;\n    } catch (error) {\n        console.error(`延迟检测失败 (${url}):`, error.message);\n        // 如果检测失败或超时，返回一个较大的延迟值\n        return Infinity;\n    }\n}\n\n/**\n * 检测所有线路的延迟 (流式版本)\n * @param {function(string, number)} onResult - 当一个线路检测完成时的回调函数 (key, latency)\n * @param {function()} onComplete - 当所有线路检测完成时的回调函数\n * @param {string} prefix - 只检测指定前缀的线路\n */\nasync function checkAllLatenciesStream(onResult, onComplete, prefix = '') {\n    // 过滤出指定前缀的线路\n    const filteredSourceMap = {};\n    for (const [key, config] of Object.entries(SOURCE_MAP)) {\n        if (key.startsWith(prefix)) {\n            filteredSourceMap[key] = config;\n        }\n    }\n    \n    const promises = Object.entries(filteredSourceMap).map(async ([key, config]) => {\n        const latency = await checkLatency(config.path);\n        onResult(key, latency);\n    });\n\n    // 等待所有检测完成\n    await Promise.all(promises);\n    onComplete();\n}\n\n/**\n * 检测所有线路的延迟 (旧版一次性返回)\n * @param {string} prefix - 只检测指定前缀的线路\n * @returns {Promise<Object>} 包含所有线路延迟的对象\n */\nasync function checkAllLatencies(prefix = '') {\n    // 过滤出指定前缀的线路\n    const filteredSourceMap = {};\n    for (const [key, config] of Object.entries(SOURCE_MAP)) {\n        if (key.startsWith(prefix)) {\n            filteredSourceMap[key] = config;\n        }\n    }\n    \n    const latencies = {};\n    \n    // 创建所有延迟检测的Promise\n    const latencyPromises = Object.entries(filteredSourceMap).map(async ([key, config]) => {\n        const latency = await checkLatency(config.path);\n        return { key, latency };\n    });\n    \n    // 等待所有检测完成\n    const results = await Promise.all(latencyPromises);\n    \n    // 将结果整理成对象\n    results.forEach(({ key, latency }) => {\n        latencies[key] = latency;\n    });\n    \n    return latencies;\n}\n\n/**\n * 找到延迟最低的线路\n * @param {Object} latencies - 包含所有线路延迟的对象\n * @returns {string|null} 延迟最低的线路key，如果没有可用线路则返回null\n */\nfunction findFastestLine(latencies) {\n    let fastestKey = null;\n    let minLatency = Infinity;\n    \n    for (const [key, latency] of Object.entries(latencies)) {\n        // 忽略检测失败的线路(延迟为Infinity)\n        if (latency < minLatency) {\n            minLatency = latency;\n            fastestKey = key;\n        }\n    }\n    \n    return fastestKey;\n}\n\n// 导出函数\nexport { checkLatency, checkAllLatenciesStream, checkAllLatencies, findFastestLine };